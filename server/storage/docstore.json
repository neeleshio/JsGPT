{"docstore/metadata": {"e4cd3059-bc6d-489f-85df-2329dde32c70": {"doc_hash": "b807e27340670efc3689a9280a5a7e016515a7cb8851c9ffb2a0f5da9da18cd3"}, "6cd99785-1505-4992-9f86-c9fd6aef2540": {"doc_hash": "5b607301a72309a5c00941df3eeac195eb41e2237ca86239d2033b91cd0f1b12"}, "df87b5a9-b063-4d65-a227-6d082b782562": {"doc_hash": "0455508954db1acce7254edd00a54361c2a4ddfdda348254f5cc73a5501ac061"}, "84f729ee-a630-4afd-8c9c-4763d50e7b64": {"doc_hash": "7473e1385e8741add9d7dfe3f66f85750249b189eabc34c21fb44aea54aca153"}, "6929f4b7-7a96-4842-b9b7-0c1b5891af38": {"doc_hash": "44d22a9cebdd430c6060ac4a53ba6f8bbc040317681a1c06bec35f7783aa31b5"}, "f1442804-5037-46c3-ae03-ece5c37987bd": {"doc_hash": "cc8345dc2d85d8809e5f7257deeb6764016e4246960f84397fb321c4a7b00045"}, "30c3313c-c4fb-4149-9321-fc288b72217c": {"doc_hash": "ed7f5de9e7a673a5c47b8cd36cc36f8364153773a1c9e10a310132f5006d1b28"}, "8f8e8124-8460-40a5-88cb-219d03c70271": {"doc_hash": "d15ac7fa633d4fb31600a4326fa130194066054b9a0aad6d0c2bb51b180aa5b7"}, "a13cf65c-b750-45c8-a3a5-99002c5888f7": {"doc_hash": "fe1fb9e95d2181f6018ea2fbe1a33146323cb79b354c41413e3ccb44d0020897"}, "236ff8a7-8737-4e03-a353-2d27636dd33c": {"doc_hash": "446fd1bdc88164dbbd9b6d9e10f75ade952591bc2d0a34a38b2b2b19154da72c"}, "f03c2b9f-f420-4aa6-a919-18672625617e": {"doc_hash": "0a2ab118b43929f8cbc51e01dc79e7a37ee9c915b7230641fbb478f9f181a404"}, "eb3bf8b9-04a2-481f-95c0-43dc9d0fd123": {"doc_hash": "388730d8791fc6e3ae103913a7030a4a4a205f7ae3995f9f6de0c624c161afaa"}}, "docstore/data": {"6cd99785-1505-4992-9f86-c9fd6aef2540": {"__data__": {"text": "\ufeff50 Javascript Concepts\nJavaScript is a lightweight, Just-in-time compiled, Synchronous Single threaded, Loosly typed programming language.\n\n\n1. Data types\nJavaScript provides 2 types of data-types, Primitive type and Non-Primitive type.\nPrimitive type: Data structure that allows you to store only single data type values. 1. String 2. Number 3. BigInt 4. Boolean 5. Null 6. Undefined 7. Symbol \nNonPrimitive type: Data structure that allows you to store multiple data type values. 1. Array 2. Object\n\u2b06 Back to Top\n2. JavaScript vs ECMAScript vs ES6\nJavaScript is a programming language.\nECMAScript is the specification for JavaScript.\nES6 is the most prominent version of JavaScript, released in the year 2015.\n\u2b06 Back to Top\n3. Most used ES6 features.\n1. Let & Const\n2. Template Literals\n3. Arrow Functions\n4. Rest & Spread operators\n5. Default parameters\n6. Destructuring assignment\n7. Classes\n8. Promises\n9. Modules\n\u2b06 Back to Top\n4. typeof\ntypeof operator can be used to find the data type of a value.\ntypeof \"superman\" // 'string'\ntypeof \"\" // 'string'\ntypeof 100 // 'number'\ntypeof NaN // 'number'\ntypeof true // 'boolean'\ntypeof false // 'boolean'\ntypeof 1n // 'bigint'\ntypeof BigInt(9007199254740991) // 'bigint'\ntypeof function(){} // 'function'\ntypeof [] // 'object'\ntypeof {} // 'object'\ntypeof null // 'object'\ntypeof new Date() // 'object'\ntypeof undefined // 'undefined'\ntypeof mycar // 'undefined'\n\u2b06 Back to Top\n5. Execution Context & Global Execution Context\nEverything in JavaScript happens inside an Execution context. An Execution context is like a container or environment where the JavaScript code evaluated & executed.\nA Global execution context gets created even before it starts to execute any code, so it\u2019ll always present at the bottom of the call stack. All the global code i.e. code which is not inside any function or object is executed inside the Global execution context. Inside the Global execution contex, a new Execution context gets created on every time a new function is invoked.\nExecution context is composed of 2 components,\n1. Memory component\nThis is the place where all the variables and functions are stored as a key-value pairs.\n2. Code component\nThis is where the code gets executed one line at a time.\n\u2b06 Back to Top\n7. Call stack\nA Call stack is a data structure where data can be pushed & popped and follows the LIFO( Last in First out ) principle.\nIn JavaScript, the JavaScript Engine has its own Call stack which keeps track of functions to be executed. So whenever a function is invoked, it is pushed into the Call stack.\n\u2b06 Back to Top\n8. Synchronous Single threaded\nJavaScript is a Synchronous Single threaded language. So when we say Single threaded that means it can only execute one command at a time.\nSo when we say Synchronous Single threaded that means it can move to the next command only after it finishes executing the current line/command.\n\u2b06 Back to Top\n9. Hoisting\nIn plain english Hoist means raise or lift. In Javascript Hoisting is the default behaviour of moving all the declarations to the top of their scope before code execution. So if we try to access any variables or functions before their declaration, JS won\u2019t throw any error.\nIn other words, we can also say that Hoisting is a phenomenon in JS by which we can access variables & functions even before their declaration.\nconsole.log(x) // undefined\nconsole.log(foo()) // hello from foo\n\nvar x = \"hello\"\n\nfunction foo() {\n  console.log(\"hello from foo\")\n}\n\u2b06 Back to Top\n10. Arrow functions\nArrow functions are an alternative to traditional functions, introduced in ES6. Arrow functions are always Anonymous functions, so to call them", "doc_id": "6cd99785-1505-4992-9f86-c9fd6aef2540", "embedding": null, "doc_hash": "5b607301a72309a5c00941df3eeac195eb41e2237ca86239d2033b91cd0f1b12", "extra_info": null, "node_info": {"start": 0, "end": 3656}, "relationships": {"1": "e4cd3059-bc6d-489f-85df-2329dde32c70", "3": "df87b5a9-b063-4d65-a227-6d082b782562"}}, "__type__": "1"}, "df87b5a9-b063-4d65-a227-6d082b782562": {"__data__": {"text": "Hoisting\nIn plain english Hoist means raise or lift. In Javascript Hoisting is the default behaviour of moving all the declarations to the top of their scope before code execution. So if we try to access any variables or functions before their declaration, JS won\u2019t throw any error.\nIn other words, we can also say that Hoisting is a phenomenon in JS by which we can access variables & functions even before their declaration.\nconsole.log(x) // undefined\nconsole.log(foo()) // hello from foo\n\nvar x = \"hello\"\n\nfunction foo() {\n  console.log(\"hello from foo\")\n}\n\u2b06 Back to Top\n10. Arrow functions\nArrow functions are an alternative to traditional functions, introduced in ES6. Arrow functions are always Anonymous functions, so to call them we need to assign it to a variable.\nconst square = a => a * a;\n\nconsole.log(square(2)) // 4\nusing Arrow functions, curly braces, parenthesis, function keyword & return keywords become optional.\n\u2b06 Back to Top\n11. Arrow functions hoisting\nLike traditional functions, arrow functions are not hoisted so we can\u2019t call them before their declaration.\nfoo() // Uncaught TypeError: foooo is not a function\n\nbar() // Uncaught ReferenceError: fooo is not defined\n\nvar foo = () => {\n  console.log(\"hello from foo\")\n}\n\nconst bar = () => {\n  console.log(\"hello from bar\")\n}\nBecause it behaves just like another variable. It doesn\u2019t behave like a function.\n\u2b06 Back to Top\n12. Window object\nWindow is the global object present in the browsers. Every time we run a JS program, the JS engine creates the window object.\nIt consists of lot of useful methods & properties and all the global space variables & functions gets attached to the window object so we can access them anywhere in our program.\nvar a = 10\nvar b = 20\n\nconsole.log(window.a) // 10\nconsole.log(window.b) // 20\nAt global level this points to window object.\nthis === window // true\n\u2b06 Back to Top\n13. Global scope\nAnything we write inside JS which is not inside the function or block.\nvar x = 10   --> global scoped varibale\n\nfunction foo () {   --> global scoped function\n  var y = 20        --> not global scoped\n}\n\u2b06 Back to Top\n14. this keyword\n1. \u2018this\u2019 keyword refers to the current object\n2. \u2018this\u2019 keyword always or mostly used in object oriented programming.\n3. If we get rid of \u2018this\u2019, we will be left with Javscript as a functional programming language.\nThe \u2018this\u2019 keyword refers to different objects depending on how it is used:\n1. In Method:\nIn an object method, \u2018this\u2019 refers to the object.\nconst person = {\n  fname: 'neelesh',\n  lname: 'shetty',\n  fullName: function() {\n      return this.fname + ' ' + this.lname;  ----> 'this' refers to 'person' object itself.\n   }\n}\n\nperson.fullName() // neelesh shetty\n2. \u2018this\u2019 alone:\nlet x = this.\nconsole.log(x) // Window {window: Window, self: Window, document: document, name: 'iframeResult', location: Location, \u2026} \nwhen used alone, this refers to global object. Becoz \u2018this\u2019 is in global scope.\nIn a browser window the global object is [object Window].\nIn strict mode:\n'use strict'\nlet y = this.\nconsole.log(y) // Window {window: Window, self: Window, document: document, name: 'iframeResult', location: Location, \u2026} \n3. In a function:\nIn a function, it refers to global object.\nfunction hello() {\n  console.log(this)\n}\n\nhello() // Window {window: Window, self: Window, document: document, name: 'iframeResult', location: Location, \u2026} \nIn strict mode:\n'use strict'\nfunction", "doc_id": "df87b5a9-b063-4d65-a227-6d082b782562", "embedding": null, "doc_hash": "0455508954db1acce7254edd00a54361c2a4ddfdda348254f5cc73a5501ac061", "extra_info": null, "node_info": {"start": 3030, "end": 6447}, "relationships": {"1": "e4cd3059-bc6d-489f-85df-2329dde32c70", "2": "6cd99785-1505-4992-9f86-c9fd6aef2540", "3": "84f729ee-a630-4afd-8c9c-4763d50e7b64"}}, "__type__": "1"}, "84f729ee-a630-4afd-8c9c-4763d50e7b64": {"__data__": {"text": "// Window {window: Window, self: Window, document: document, name: 'iframeResult', location: Location, \u2026} \nwhen used alone, this refers to global object. Becoz \u2018this\u2019 is in global scope.\nIn a browser window the global object is [object Window].\nIn strict mode:\n'use strict'\nlet y = this.\nconsole.log(y) // Window {window: Window, self: Window, document: document, name: 'iframeResult', location: Location, \u2026} \n3. In a function:\nIn a function, it refers to global object.\nfunction hello() {\n  console.log(this)\n}\n\nhello() // Window {window: Window, self: Window, document: document, name: 'iframeResult', location: Location, \u2026} \nIn strict mode:\n'use strict'\nfunction hey() {\n  console.log(this)\n}\n\nhey() // undefined\n4. Event handler:\nWhen a function is used as an event handler, its \u2018this\u2019 is set to the element on which the listener is placed.\n<button onclick=\"this.style.display='none'\">Click to remove button</button>\nso when we click the button, the above style will get added.\n\u2b06 Back to Top\n15. Arrow function:\nAn arrow function expression is a compact alternative to a traditional function expression.\nCharacteristics:\n1. Using the arrow function, curly braces, paranthesis, function & return keywords become optional.\n2. Arrow functions are always Anonymous functions, so to call arrow function we need to assign it to a variable.\n3. Arrow function expressions should only be used for non-method functions because they do not have their own this.\n* const obj = {\n   fname: 'neel',\n   lname: 'shett',\n   getName: () => console.log(this.fname, this) ---> 'this' points to the global window object. \n}\n\nobj.getName() // undefined, Window {window: Window, self: Window, document: document, name: 'iframeResult', location: Location, \u2026} \n   4. Arrow functions do not have arguments binding unlike regular functions.\n   * const x = () => {\n   console.log(arguments);\n}\n\nx(4,6,7) // ReferenceError: Can't find variable: arguments\n   * but with regular function,\n   * let x = function () {\n   console.log(arguments);\n}\n\nx(4,6,7); // Arguments [4, 6, 7]\n   * To solve this issue, we can use spread operator:\n   * let x = (...args) => {\n   console.log(args);\n}\n\nx(4,6,7); // [4, 6, 7]\n      5. Arrow functions provide better syntax to write promises & callbacks.\n      * ES5\n      * asyncFunction().then(function() {\n   return asyncFunction1();\n}).then(function() {\n   return asyncFunction2();\n}).then(function() {\n   finish;\n});\n         * ES6\n         * asyncFunction()\n .then(() => asyncFunction1())\n .then(() => asyncFunction2())\n .then(() => finish);\n            6. You cannot use an arrow function as a constructor. javascript      let Foo = () => {};      let foo = new Foo(); // TypeError: Foo is not a constructor\n16. Undefined vs not defined vs null\nundefined keyword or property indicates that a variable has not been assigned/initialized a value. undefined variables takes up their own memory in the memory space.\nnot defined property indicates that a variable is not at all present in the code and in the memory space.\nnull is an object in JavaScript. null means nothing & is used to represent an intentional absence of value.\n\u2b06 Back to Top\n17. Scope\nScope defines the visibility & availability of variables and functions, meaning it\u2019s a place where a defined variable/function can have its existence", "doc_id": "84f729ee-a630-4afd-8c9c-4763d50e7b64", "embedding": null, "doc_hash": "7473e1385e8741add9d7dfe3f66f85750249b189eabc34c21fb44aea54aca153", "extra_info": null, "node_info": {"start": 6496, "end": 9805}, "relationships": {"1": "e4cd3059-bc6d-489f-85df-2329dde32c70", "2": "df87b5a9-b063-4d65-a227-6d082b782562", "3": "6929f4b7-7a96-4842-b9b7-0c1b5891af38"}}, "__type__": "1"}, "6929f4b7-7a96-4842-b9b7-0c1b5891af38": {"__data__": {"text": "         6. You cannot use an arrow function as a constructor. javascript      let Foo = () => {};      let foo = new Foo(); // TypeError: Foo is not a constructor\n16. Undefined vs not defined vs null\nundefined keyword or property indicates that a variable has not been assigned/initialized a value. undefined variables takes up their own memory in the memory space.\nnot defined property indicates that a variable is not at all present in the code and in the memory space.\nnull is an object in JavaScript. null means nothing & is used to represent an intentional absence of value.\n\u2b06 Back to Top\n17. Scope\nScope defines the visibility & availability of variables and functions, meaning it\u2019s a place where a defined variable/function can have its existence and beyond that it cannot be accessed.\nIn JS, we can create scope using code blocks, functions & modules.\n\u2b06 Back to Top\n18. Types of scope\nThere are 3 types of scope in JS:\n#### 1. Global scope Any variable that is not inside any function or block, is inside the global scope & they are called global scoped variables.\nThe variables in global scope can be accessed from anywhere in the program.\nvar message = \"hello\"\n\nfunction printHello() {\n  console.log(message)\n}\n\nprintHello()  // \"hello\"\n#### 2. Function scope When a variable is declared inside a function, it is only accessible within that function and cannot be used outside that function\nvar is a function scoped, becoz:\nfunction hello() {\n  if (true) {\n    var a = 1;  --- function scoped\n    let b = 2;  --- block scoped\n    const c = 3; -- block scoped\n\n    console.log(a);\n    console.log(b);\n    console.log(c);\n  }\n\n  console.log(a);\n  console.log(b);\n  console.log(c);\n}\n\nhello();\n\noutput: \n1\n2\n3\n1\nReference error: b is not defined.\nSo we can access var throughout the function.\n#### 3. Block scope A variable when declared inside the if or switch conditions or inside for or while loops, are accessible within that particular condition or loop.\nAs you can see in the above hello example, we cannot accesss b or c outside its if block.\n\u2b06 Back to Top\n19. Lexical scope/environment\nLexical scoping is the environment that holds the variables of the current scope as well as the outer scope.\nor,\nLexical Environment is the local memory along with the lexical environment of its parent.\nor,\nLexical scoping is a type of object oriented programming according to which, a child can access parent scope and global scope.\n\u2b06 Back to Top\n20. Scope chain\nIt is the process in which, JavaScript engine searches for the value of the variables in the scope of the functions. However, the search is in a lexical manner.\nFirst of all the engine looks out in the current scope of the current function. If not found, it finds it in the parent funtion. If not there, global scope is the last place it checks in.\nHence, to find value of the required variabe, a chain is formed by looking in the different scopes.\n```\nconst a = \"Hello world\"; -- global scope variable\n\nfunction first() {\n   const b = \"I am Neelesh.\"; -- parent scope variable\n   second();\n\n   function second() {\n       const c = \"A frontend developer\"; -- current/local scope variable\n       console.log(a + b + c);\n   }\n}\nfirst();\n// Hello world I am Neelesh. A frontend developer\n\t\n\n\u2b06 Back to Top\n21. Lexical \u2018this\u2019\nArrow functions do not have their own value of this. The value of this in an arrow function is inherited from the enclosing (lexical) scope.\nIt is just a fancy way of saying its value is static and determined by the scope \u201cthis\u201d is defined in.\nconst myFunction = () => {\n ", "doc_id": "6929f4b7-7a96-4842-b9b7-0c1b5891af38", "embedding": null, "doc_hash": "44d22a9cebdd430c6060ac4a53ba6f8bbc040317681a1c06bec35f7783aa31b5", "extra_info": null, "node_info": {"start": 9770, "end": 13329}, "relationships": {"1": "e4cd3059-bc6d-489f-85df-2329dde32c70", "2": "84f729ee-a630-4afd-8c9c-4763d50e7b64", "3": "f1442804-5037-46c3-ae03-ece5c37987bd"}}, "__type__": "1"}, "f1442804-5037-46c3-ae03-ece5c37987bd": {"__data__": {"text": "global scope variable\n\nfunction first() {\n   const b = \"I am Neelesh.\"; -- parent scope variable\n   second();\n\n   function second() {\n       const c = \"A frontend developer\"; -- current/local scope variable\n       console.log(a + b + c);\n   }\n}\nfirst();\n// Hello world I am Neelesh. A frontend developer\n\t\n\n\u2b06 Back to Top\n21. Lexical \u2018this\u2019\nArrow functions do not have their own value of this. The value of this in an arrow function is inherited from the enclosing (lexical) scope.\nIt is just a fancy way of saying its value is static and determined by the scope \u201cthis\u201d is defined in.\nconst myFunction = () => {\n  console.log(this);\n};\n\nmyFunction() // window\n\u2b06 Back to Top\n22. Let & Const\n            1. Both are introduced in ES6.\n            2. Variables defined with let can be Reassigned.\n            3. Variables defined with const cannot be Reassigned.\nHoisting\nlet & const are also hoisted, but very deferently than var declaration.\nconsole.log(b)  //undefined\nconsole.log(a)  //Reference error: a is not defined\n\nlet a = 10\nvar b = 100\nHere, b gets its memory allocated in the global scope becoz of var. But, a gets its memory allocated in the seperate memory space called Script. So we can\u2019t access let & const before it gets its value.\nNote: I tried the above code in different places like, 1. codesandbox.io => output is: // undefined. 2. nodejs => output is: // ReferenceError: Cannot access \u2018a\u2019 before initialization. 3. browser console => output is: // ReferenceError: \u2018a\u2019 is not defined. 4. browser console with index.js => output is: // ReferenceError: Cannot access \u2018a\u2019 before initialization.\n\u2b06 Back to Top\n23. Var vs Let vs Const\nvar\n\tlet & const\n\t1. var is a function scoped.\n\t1. let & const are block scoped.\n\t2. Variables defined with var can be redeclared &\n\t2. let can be reasigned but cannot be redeclared.\n\treasigned.\n\tconst cannot be reasigned or redeclared.\n\t3. It can be accessed without initialization as\n\t3. It cannot be accessed without initialization\n\tits default value is \u201cundefined\u201d.\n\totherwise it will give \u2018referenceError\u2019.\n\t\u2b06 Back to Top\n24. Const with Objects\nConst allows us to change the Object properties.\nconst obj = { name: 'Bob' }\nobj.name = 'silly'\n\nconsole.log(obj) // { name: 'silly' }\nSo, const only prevent reassigning of primitive data types.\n\u2b06 Back to Top\n25. Temporal dead zone\nThe time/period b/w let or const variable is hoisted & till it initialised some value.\nSo until it gets some values, the let and const will be in temporal dead zone.\n\u2b06 Back to Top\n26. Reference vs Syntax vs Type errors\n1. Reference error:\nWhen there is no variable found in the memory.\n2. Syntax error:\nWhen there are mistakes in the source code, such as spelling and punctuation errors, incorrect labels, and so on.\n3. Type error:\nwhen a value is not of the expected type.\nEx: if a string is attempted to be multiplied with an integer, a TypeError is generated.\n\u2b06 Back to Top\n27. Declaration vs Initialisation\nDeclaration declares the creation of variables and functions. or just naming the variable.\nInitialization occurs when you assign an initial value to a variable.\n\u2b06 Back to Top\n28. Arguments vs Parameters\nArguments are the values that are paased to the function during the function call.\nParameters are the variables that are used to recieve the arguments that are passed to the function.\nfunction", "doc_id": "f1442804-5037-46c3-ae03-ece5c37987bd", "embedding": null, "doc_hash": "cc8345dc2d85d8809e5f7257deeb6764016e4246960f84397fb321c4a7b00045", "extra_info": null, "node_info": {"start": 13450, "end": 16786}, "relationships": {"1": "e4cd3059-bc6d-489f-85df-2329dde32c70", "2": "6929f4b7-7a96-4842-b9b7-0c1b5891af38", "3": "30c3313c-c4fb-4149-9321-fc288b72217c"}}, "__type__": "1"}, "30c3313c-c4fb-4149-9321-fc288b72217c": {"__data__": {"text": "error:\nWhen there is no variable found in the memory.\n2. Syntax error:\nWhen there are mistakes in the source code, such as spelling and punctuation errors, incorrect labels, and so on.\n3. Type error:\nwhen a value is not of the expected type.\nEx: if a string is attempted to be multiplied with an integer, a TypeError is generated.\n\u2b06 Back to Top\n27. Declaration vs Initialisation\nDeclaration declares the creation of variables and functions. or just naming the variable.\nInitialization occurs when you assign an initial value to a variable.\n\u2b06 Back to Top\n28. Arguments vs Parameters\nArguments are the values that are paased to the function during the function call.\nParameters are the variables that are used to recieve the arguments that are passed to the function.\nfunction printName (name, city) {.  ---- Parameters\n  return `Iam {name} from {city}`;\n}\n\nprintName('Neelesh', 'Ckm') ---- Arguments\n\u2b06 Back to Top\n29. Default parameters\nDefault parameters allow named parameters to be initialized with default values if no value or undefined is passed.\nfunction multiply(a, b = 1) {  --- 'b' has been initialized with a default value 1. \n  return a * b;\n}\n\nconsole.log(multiply(5, 2));\n// Expected output: 10\n\nconsole.log(multiply(5));\n// Expected output: 5\n\u2b06 Back to Top\n30. Pass by value vs Pass by reference\nWhen a function is called, the arguments can be passed in two ways, either Pass by value or Pass by reference (address).\nPrimitive data types such as string, number, null, undefined, and boolean, are passed by value while non-primitive data types such as objects, arrays, and functions are passed by reference.\nPass by value in JavaScript means that a copy of the actual parameter\u2019s value is made in memory. The original value and the copied value are independent of each other as they both have a different space in memory i.e., on changing the value inside the function, the variable outside the function is not affected.\nUnlike pass by value, pass by reference in does not create a new space in the memory, instead, we pass the reference/address of the actual parameter. Thus, if we change the value of the variable inside the function, then the original value also gets changed.\n\u2b06 Back to Top\n31. Block scope\nWe use block to combine multiple statements.\n{\n        ---- this is a Block.\n}\nEx: if else statements, for loops etc.\n\u2b06 Back to Top\n32. Shadowing\nshadowing occurs when a variable declared in a certain scope (e.g. a local variable) has the same name as a variable in an outer scope (e.g. a global variable). When this happens, the outer variable is said to be shadowed by the inner variable.\nEx.1:\nvar a = 100;\n\n{\n  var a = 20;\n}\n\nconsole.log(a) // 20\nFirst it assigns 100 to a & then when it comes at block scoped a, it again assigns 20 to the same a in the memory. So, value of a is 20.\nEx.2:\nlet b = 100;\n\n{\n  let b = 20;\n}\n\nconsole.log(a) // 100\nBecoz, let is block scoped & shadowing won\u2019t happen. Same foe const.\nNote: It actually creates 2 b variables, one in Global & another in Block.\nEx.3:\nlet c = 10;\n\n{\n  var c = 20;     ---- illigal shadowing. \n}\n\nconsole.log(a) // SyntaxError: Identifier 'a' has already been declared\nEx.4:\nvar a = 100\n\n{\n    let a = 20    ---- legal\n}\n\nconsole.log(a) // 100\n\u2b06 Back to Top\n33. Clousers\nClosure is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment).\nor,\nClosure gives you access to an outer function\u2019s scope from an inner", "doc_id": "30c3313c-c4fb-4149-9321-fc288b72217c", "embedding": null, "doc_hash": "ed7f5de9e7a673a5c47b8cd36cc36f8364153773a1c9e10a310132f5006d1b28", "extra_info": null, "node_info": {"start": 16624, "end": 20089}, "relationships": {"1": "e4cd3059-bc6d-489f-85df-2329dde32c70", "2": "f1442804-5037-46c3-ae03-ece5c37987bd", "3": "8f8e8124-8460-40a5-88cb-219d03c70271"}}, "__type__": "1"}, "8f8e8124-8460-40a5-88cb-219d03c70271": {"__data__": {"text": "block scoped & shadowing won\u2019t happen. Same foe const.\nNote: It actually creates 2 b variables, one in Global & another in Block.\nEx.3:\nlet c = 10;\n\n{\n  var c = 20;     ---- illigal shadowing. \n}\n\nconsole.log(a) // SyntaxError: Identifier 'a' has already been declared\nEx.4:\nvar a = 100\n\n{\n    let a = 20    ---- legal\n}\n\nconsole.log(a) // 100\n\u2b06 Back to Top\n33. Clousers\nClosure is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment).\nor,\nClosure gives you access to an outer function\u2019s scope from an inner function.\nor,\nFunction along with its lexical scope forms a closure.\nfunction outer () {\n  const a = 7;\n  \n  function inner () {\n    console.log(a)\n  }\n  \n  return inner;\n}\n\nconst z = outer();\n.\n...million lines of code\n.\nz() // 7\nSo, even if we execute the returned function outside its scope, it still remembers its variables with the help of clousers.\nfunction x() {\n  let a = 900;\n  \n  function y() {\n    let b = 7;\n    \n    function z() {\n      console.log(a, b)              Closure:(z)\n    }                                   b: 900\n    return z;                        Closure:(y)\n  }                                     a: 7\n  return y;\n}\n\n const a = x()    or just x()()() // 900, 7      \n const b = a()   \n b() // 900, 7\nNote: Clousers remembers the reference to the variables & not the actual value.\n\u2b06 Back to Top\n34. Uses of Clousers\n            1. Module design pattern\n            2. Currying\n            3. Functions like once\n            4. memoize\n            5. Maintaining state in async world\n            6. SetTimeouts\n            7. Iterators etc.\n\u2b06 Back to Top\n35. Disadvantages of Clousers\n            1. Overconsumption of memory becoz variables are not garbage collected.\n            2. If not handled properly then memory leak could happen.\n\u2b06 Back to Top\n36. SetTimeout\nJavaScript doesn\u2019t wait for none.\nfunction x() {\n  const a = 1;\n  \n  setTimeout(() => {\n    console.log(a)\n  }, [3000])\n  \n  console.log('hi')\n}\n\nx()\n//'hi'\n// 1\n\u2b06 Back to Top\n37. Data hiding using Clousers\nConsider this counter function,\nlet count = 0\n\nfunction counter() {\n    counter++\n}\n\ncounter1()\nBut if we want to prevent any function accessing the count variable, we wrap this with another function like below.\nfunction counter() {\n    let count = 0\n    \n    return function increment() {\n        count++\n        return count\n    }\n}\n\nconst counter1 = counter();\ncounter1()  // 1\ncounter1()  // 2  \ncounter1()", "doc_id": "8f8e8124-8460-40a5-88cb-219d03c70271", "embedding": null, "doc_hash": "d15ac7fa633d4fb31600a4326fa130194066054b9a0aad6d0c2bb51b180aa5b7", "extra_info": null, "node_info": {"start": 20264, "end": 22759}, "relationships": {"1": "e4cd3059-bc6d-489f-85df-2329dde32c70", "2": "30c3313c-c4fb-4149-9321-fc288b72217c", "3": "a13cf65c-b750-45c8-a3a5-99002c5888f7"}}, "__type__": "1"}, "a13cf65c-b750-45c8-a3a5-99002c5888f7": {"__data__": {"text": " setTimeout(() => {\n    console.log(a)\n  }, [3000])\n  \n  console.log('hi')\n}\n\nx()\n//'hi'\n// 1\n\u2b06 Back to Top\n37. Data hiding using Clousers\nConsider this counter function,\nlet count = 0\n\nfunction counter() {\n    counter++\n}\n\ncounter1()\nBut if we want to prevent any function accessing the count variable, we wrap this with another function like below.\nfunction counter() {\n    let count = 0\n    \n    return function increment() {\n        count++\n        return count\n    }\n}\n\nconst counter1 = counter();\ncounter1()  // 1\ncounter1()  // 2  \ncounter1()  // 3  \nBy this method, the variables are safe & also we can create any number of counter instances like counter2 = counter(), this will be a new counter which starts from 0.\n\u2b06 Back to Top\n38. Garbage collectors\nIf there is any unused variable in the memory, those are garbage collected.\n\u2b06 Back to Top\n39. Types of functions\n1. Function statement:\nA named function is a Function statement\nfunction a() {\n  //.....\n}\n2. Function expression\nThis is same as function statement but we can omit the function name.\nconst a = function () {\n  //....\n}\n3. Anonymous function\nFunction statement which doesn\u2019t have a name or identity.\nfunction () {\n  //....\n}\nNote: you can\u2019t call these type of functions & it gives SynaxError.\n4. Named function expression\nconst a = function xyz() {\n  console.log('hi')\n}\na() // hi\nxyz() // ReferenceError: xyz is not defined.\nSo, we can\u2019t access xyz outside of that function, becoz it is created as a local scope. Try console logging xyz inside the xyz function itself & you will get the output of the whole xyz function.\n\u2b06 Back to Top\n40. Function statement vs Function expression\nMajor difference is Hoisting.\na() // 'statement'           ---> a: fn{..}\nb() // b is not a function ---> b: undefined\n\nfunction a() {\n  console.log('statement')\n}\n\nconst b = function() {\n  console.log('expression')\n}\nSo, function statements are hoisted as a variables.\n\u2b06 Back to Top\n41. Arguments object\nThe arguments of a function are maintained in an array-like object. Within a function, you can address the arguments passed to it as follows:\narguments[i];\nfunction myConcat(separator) {\n  let result = \"\"; // initialize list\n  // iterate through arguments\n  for (let i = 1; i < arguments.length; i++) {\n    result += arguments[i] + separator;\n  }\n  return result;\n}\n\nmyConcat(\"; \", \"elephant\", \"giraffe\", \"lion\", \"cheetah\") // \"elephant; giraffe; lion; cheetah; \"\n42. Function constructors\nThe Function() constructor creates a new Function object. Calling the constructor directly can create functions dynamically, but suffers from security and similar (but far less significant) performance issues as eval() becoz we are trying to evaluate string as Javascript.\nFunction constructor creates functions which execute in the global scope only.\nconst sum = new Function('a', 'b', 'return a + b');\n\nsum(2, 6) // 8\nNote: Function() can be called with or without new. Both create a new Function instance.\nWarning: This type of methods are not recommended.\n\u2b06 Back to Top\n43. Module design pattern and IIFE\nThe module pattern is a design pattern used for improving the maintainability and reusability of the code by creating public and private access levels.\nSometimes called encapsulation, it protects the value inside a module from being accessed from other scopes.\n\u2b06 Back to Top\n44. First class functions or citizens\nA programming language is said to have First-class", "doc_id": "a13cf65c-b750-45c8-a3a5-99002c5888f7", "embedding": null, "doc_hash": "fe1fb9e95d2181f6018ea2fbe1a33146323cb79b354c41413e3ccb44d0020897", "extra_info": null, "node_info": {"start": 22800, "end": 26223}, "relationships": {"1": "e4cd3059-bc6d-489f-85df-2329dde32c70", "2": "8f8e8124-8460-40a5-88cb-219d03c70271", "3": "236ff8a7-8737-4e03-a353-2d27636dd33c"}}, "__type__": "1"}, "236ff8a7-8737-4e03-a353-2d27636dd33c": {"__data__": {"text": "far less significant) performance issues as eval() becoz we are trying to evaluate string as Javascript.\nFunction constructor creates functions which execute in the global scope only.\nconst sum = new Function('a', 'b', 'return a + b');\n\nsum(2, 6) // 8\nNote: Function() can be called with or without new. Both create a new Function instance.\nWarning: This type of methods are not recommended.\n\u2b06 Back to Top\n43. Module design pattern and IIFE\nThe module pattern is a design pattern used for improving the maintainability and reusability of the code by creating public and private access levels.\nSometimes called encapsulation, it protects the value inside a module from being accessed from other scopes.\n\u2b06 Back to Top\n44. First class functions or citizens\nA programming language is said to have First-class functions when functions in that language are treated like any other variable.\nFor example, in such a language, a function can be passed as an argument to other functions, can be returned by another function and can be assigned as a value to a variable.\nAssigning a function to a variable:\nconst foo = () => {\n  console.log(\"foobar\");\n};\nfoo(); // Invoke it using the variable\nPassing a function as an argument:\nfunction greeting(helloMessage, name) {\n  console.log(helloMessage() + name);\n}\nfunction sayHello() {\n  return \"Hello, \";\n}\n// Pass `sayHello` as an argument to `greeting` function\ngreeting(sayHello, \"JavaScript!\");\n// Hello, JavaScript!\nReturning a function:\nfunction sayHello() {\n  return () => {\n    console.log(\"Hello!\");\n  };\n}\n\u2b06 Back to Top\n45. Pure and Impure functions\nA pure function is a function that returns the same result if the same arguments(input) are passed to the function.\n            1. The return value of the function on the function call should only be dependent on the input function arguments.\n            2. It should not modify any non-local state. It means the function should not manipulate anything other than the data stored in the local variables declared within the function.\nfunction operationAdd(a, b){ // A pure function adding two integers passed in it.\n    return a+b;\n}\n\nfunction operationDivide(a, b){  // Pure function to divide two integers passed in it.\n    return a/b;\n}\n\nfunction operationMulti(a, b){    // Pure function to multiple two integers passed in it.\n    return a*b;\n}\nconsole.log(        // Calling all the pure functions\n  operationAdd(2,5),\n  operationMulti(3,2),\n  operationDivide(20,5)\n);\nWhy Use Pure Functions?\n            1. Better Readability: Pure functions increase the readability of the javascript code because of its simplicity.\n            2. Testable: It\u2019s easier to perform unit testing on a pure function than on an impure function. A pure function result only depends upon its input arguments hence the whole function can be treated as an independent entity. So we can just take that function and test it with some standard input values whose output is known.\n            3. Better Performance: Pure functions can be memoized and this makes your application faster.\nImpure function\nAn impure function gives inconsistent results or different results for the same input values.\n function impureFunc(myArray, item) {\n     return myArray.push(item);\n }\nIn the above example, we are manipulating the myArray argument and a pure function should not change(manipulate) any part of the code. That\u2019s why this is an impure function.\nReturning value dependent on the non-local state:\nconst message = 'Hi there! ';\n function myMessage(value) {\n     return `${message} ${value}`\n }\n console.log(myMessage('hello'));\nIn the above code, the", "doc_id": "236ff8a7-8737-4e03-a353-2d27636dd33c", "embedding": null, "doc_hash": "446fd1bdc88164dbbd9b6d9e10f75ade952591bc2d0a34a38b2b2b19154da72c", "extra_info": null, "node_info": {"start": 25983, "end": 29600}, "relationships": {"1": "e4cd3059-bc6d-489f-85df-2329dde32c70", "2": "a13cf65c-b750-45c8-a3a5-99002c5888f7", "3": "f03c2b9f-f420-4aa6-a919-18672625617e"}}, "__type__": "1"}, "f03c2b9f-f420-4aa6-a919-18672625617e": {"__data__": {"text": "input values whose output is known.\n            3. Better Performance: Pure functions can be memoized and this makes your application faster.\nImpure function\nAn impure function gives inconsistent results or different results for the same input values.\n function impureFunc(myArray, item) {\n     return myArray.push(item);\n }\nIn the above example, we are manipulating the myArray argument and a pure function should not change(manipulate) any part of the code. That\u2019s why this is an impure function.\nReturning value dependent on the non-local state:\nconst message = 'Hi there! ';\n function myMessage(value) {\n     return `${message} ${value}`\n }\n console.log(myMessage('hello'));\nIn the above code, the result the function is returning is dependent on the variable that is not declared inside the function, that\u2019s why this is an impure function.\nSome side effects:\n            1. Making an HTTP request\n            2. Mutating data\n            3. Printing to a screen or console\n            4. DOM Query/Manipulation\n            5. Using Math.random()\n            6. Getting the current time\n\u2b06 Back to Top\n46. Recurssion\nRecursion is a process of calling itself. A function that calls itself is called a recursive function.\nCharacteristics:\n            1. A recursive function must have a condition to stop calling itself. Otherwise, the function is called indefinitely.\n            2. Once the condition is met, the function stops calling itself. This is called a base condition.\n// program to find the factorial of a number\nfunction factorial(x) {\n    if (x < 0) return 'Invalid input'\n    if (x === 0) {\n        return 1;\n    } else {\n        return x * factorial(x - 1);\n    }\n}\nfactorial(3) // 6\n\u2b06 Back to Top\n47. Classes\nClasses are a template for creating objects.\nCharacteristics:\n            1. Classes were introduced in EcmaScript 2015 (ES6) to provide a cleaner way to follow object-oriented programming patterns.\n            2. JavaScript still follows a prototype-based inheritance model. Classes in JavaScript are syntactic sugar over the prototype-based inheritance model which we use to implement OOP concepts.\n            3. Thus the introduction of classes in JS made it easier for developers to build software around OOP concepts. It also brought in similarities to different OOP-based programming languages such as C++ and Java.\n            4. Before classes, we used constructor functions to do OOP in JavaScript. Have a look at the example below:\nfunction Pen(name, color, price) {\n    this.name = name;\n    this.color = color;\n    this.price = price;\n}\n\nconst pen1 = new Pen(\"Marker\", \"Blue\", \"$3\");\n\n// Adding function in a constructor\nPen.prototype.showPrice = function(){\n    console.log(`Price of ${this.name} is ${this.price}`);\n}\n\npen1.showPrice();\nWe can re-create the above example much cleaner with the help of the Class keyword:\nclass Pen {\n    constructor(name, color, price){\n        this.name = name;\n        this.color = color; \n        this.price = price;\n    }\n    \n    showPrice(){\n        console.log(`Price of", "doc_id": "f03c2b9f-f420-4aa6-a919-18672625617e", "embedding": null, "doc_hash": "0a2ab118b43929f8cbc51e01dc79e7a37ee9c915b7230641fbb478f9f181a404", "extra_info": null, "node_info": {"start": 29695, "end": 32746}, "relationships": {"1": "e4cd3059-bc6d-489f-85df-2329dde32c70", "2": "236ff8a7-8737-4e03-a353-2d27636dd33c", "3": "eb3bf8b9-04a2-481f-95c0-43dc9d0fd123"}}, "__type__": "1"}, "eb3bf8b9-04a2-481f-95c0-43dc9d0fd123": {"__data__": {"text": "= color;\n    this.price = price;\n}\n\nconst pen1 = new Pen(\"Marker\", \"Blue\", \"$3\");\n\n// Adding function in a constructor\nPen.prototype.showPrice = function(){\n    console.log(`Price of ${this.name} is ${this.price}`);\n}\n\npen1.showPrice();\nWe can re-create the above example much cleaner with the help of the Class keyword:\nclass Pen {\n    constructor(name, color, price){\n        this.name = name;\n        this.color = color; \n        this.price = price;\n    }\n    \n    showPrice(){\n        console.log(`Price of ${this.name} is ${this.price}`);\n    }\n}\n\nconst pen1 = new Pen(\"Marker\", \"Blue\", \"$3\");\npen1.showPrice();\n\u2b06 Back to Top\n48. Callback functions\nA callback function is a function passed into another function as an argument.\nThe benefit of using a callback function is that we can wait for the result of a previous function call and then execute another function call.\nfunction greeting(name) {.  --> callback function\n  alert(`Hello, ${name}`);\n}\n\nfunction processUserInput(cb) {\n  const name = prompt(\"Please enter your name.\");\n  cb(name);\n}\n\nprocessUserInput(greeting);\nThe above example is a synchronous callback, as it is executed immediately.\nHowever, callbacks are often used to continue code execution after an asynchronous operation has completed. A good example is the callback functions executed inside a .then() block chained onto the end of a promise after that promise fulfills or rejects.\n\u2b06 Back to Top\n49. Main thread blocking\nThe browser uses a single thread to run all the JavaScript in your page, as well as to perform layout, reflows, and garbage collection.\nThis means that long-running JavaScript functions can block the thread, leading to an unresponsive page and a bad user experience.\nFor example: An image transformation which needs 10sec to be computed, you are blocking the UI responses (ex. JS animations, clicks, inputs, typing, etc.)\nSo the browser itself could decide to take action and show a popup to the user asking whether to kill that process or keep it running.\nWorkarounds to this problem: (So we can run a long script as well as not blocking our UI)\n            1. Create a WebWorker: It is an API for running JavaScript code in a different browser\u2019s thread. Its limitation is it has no access to the DOM. It can communicate with the main thread only via messages.\nIt is useful for running your computation outside the main thread and once finished getting the response for it. Though if your code needs frequent access to read and manipulate the DOM, maybe this is not the best option.\n            2. Slice your long-task in little sub-tasks and run them asynchronously: We can use the setTimeout API for this and take advantage of the Event queue logic to have other things (Job queue and Rendering).\n\u2b06 Back to Top\n50. Event Listeners\nAn event listener is a function that runs once a specific event occurs. So, an event listener \u201clistens\u201d for an action, then calls a function that performs a related task.\nYou can listen for events on any element in the DOM. JavaScript has an addEventListener() function that you can call on any element on a web page.\ndocument.querySelector('.btn').addEventListener(\"click\", clickDemo)\n\nfunction clickDemo(){\n    console.log(\"Hi there\")\n}\nEvent-driven programming is the name of a paradigm that relies on the execution of an event to perform its functions.\n\u2b06 Back to Top", "doc_id": "eb3bf8b9-04a2-481f-95c0-43dc9d0fd123", "embedding": null, "doc_hash": "388730d8791fc6e3ae103913a7030a4a4a205f7ae3995f9f6de0c624c161afaa", "extra_info": null, "node_info": {"start": 32827, "end": 36183}, "relationships": {"1": "e4cd3059-bc6d-489f-85df-2329dde32c70", "2": "f03c2b9f-f420-4aa6-a919-18672625617e"}}, "__type__": "1"}}}